# 第二章
共两道题
## MIPS
在3台不同指令系统的计算机上运行同一程序P时，A机需要执行 $1.0∗10^8$条指令，B机需要执行$2.0∗10^8$条指令，C机需要执行$4.0∗10^8$条指令，但实际执行时间都是10s。请分别计算这3台机器在运行程序P时的实际速度，以MIPS为单位。这3台计算机在运行程序P时，哪一台性能最高？为什么？
> MIPS=million instruction per second
> $$A:\frac{1.0*10^8}{10*10^6}=10MIPS,B:\frac{2.0*10^8}{10*10^6}=20MIPS,C:\frac{4.0*10^8}{10*10^6}=40MIPS$$
> 性能一样，因为运行时间一样
## 功耗计算
对某处理器进行功耗测试，得到如下数据：时钟不翻转，电压1.05V时，电流为500mA；时钟频率为1GHz，电压1.1V时，电流为2500mA。请计算在1.1V下，此处理器的静态功耗以及500MHz下的总功耗。
> 1. 动态功耗和时钟频率成正比
> 2. $P=U*I=\frac{U^2}{R},R=\frac{U}{I}$
> 3. 电阻不变，电压恒定，静态功率不变，不受时钟频率影响
> 时钟不翻转，没有动态功耗，算出静态电阻R=2.1
> 1.1V算出静态功耗$P=\frac{U^2}{R}=\frac{1.1*1.1}{2.1}=0.576W$,总功耗2.75W，动态功耗2.174W
> 因此在0.5Ghz时，动态功耗减半，1.087W；电压不变，静态功耗不变，总功耗1.087+0.576=1.663W
# 第三章
## 随便算延迟
计算一个FO4的延迟，假设反相器的输入电容为0.0036pF，平均每个负载连线电容为0.0044pF，翻转延迟为0.023ns，每pF延迟为4.5ns
> 本课对 FO4 定义为 1 个反相器驱动 4 个相同的反相器
> FO4 延迟=本征延迟+负载延迟
> 本征延迟：元器件固有延迟，对于 反相器 是指 翻转延迟
> 负载延迟 = 每pF延迟 * (（输入电容 + 单个负载连续电容）* 负载个数)
> FO4 延迟=本征延迟+负载延迟=0.023+4.5*((0.0036+0.0044)* 4)=0.167ns
## 晶体管作图
1. 用定律转换成与非和或非的组合
2. PMOS永远接高电平，前面有反向符号。
## 定点浮点表示
送分
![[Pasted image 20240108140300.png]]
# 第四章
还没有过考题

![[Pasted image 20240108184953.png]]
直接计算
假设 CPU A 总指令数为 x，转移指令有 0.25x，条件码指令 0.25x，其它指令 0.5x
- A执行周期数 2\*0.25x+0.75x=1.25x
	则 CPU B 总指令数为 0.75x，其中转移指令 0.25x，其它指令 0.5x。
- B执行周期数 2\*0.25x+0.5x=1x当 CPU A 频率为 1.2 倍时，性能是 CPU B 的 1.2/1.25=0.96 倍
当 CPU A 频率为 1.1 倍时，性能是 CPU B 的 1.1/1.25=0.88 倍
因此 CPU A 两种情况下都差
![[Pasted image 20240108185112.png]]
1. load完之后有连续两条指令使用load的数据
	lw $1, 0($n)
	add $2, $2, $1
	bnez $1, 1f //任何将$1 作为 src 的指令都可以
2. $\frac{cycle}{cycle/second}=TIME;\frac{1-0.26x}{0.95}=1$,原先是1/1=1，现在主频降为0.95.为了保证性能不变，指令数量(CPI不变，公式中体现为周期数)需要减少。
3. 反人类，五级流水线MEM在EX后执行，如果合并指令则需要EX在MEM后执行
![[Pasted image 20240108185026.png]]
![[Pasted image 20240110121344.png]]
![[Pasted image 20240110121402.png]]

![[Pasted image 20240108185041.png]]
![[Pasted image 20240110121900.png]]

# 第五章
![[Pasted image 20240110122119.png]]
![[Pasted image 20240110122816.png]]

# 第六章
## 软流水
[软流水的方法--国科大体系结构 期末必考题-CSDN博客](https://blog.csdn.net/csdn_muxin/article/details/114491152)
## 循环展开
直接写两遍循环，注意有的延迟是3拍，死记硬背
## 多发射
![[Pasted image 20240110122951.png]]
延迟：2拍-T准备好src，T+1得到结果
![[Pasted image 20240110122938.png]]
![[Pasted image 20240110123302.png]]
# 第七章
## 单发射和双发射的循环展开
![[Pasted image 20240110135712.png]]
双发射的展开四次(根据浮点部件没有等待来决定展开次数)
![[Pasted image 20240110123421.png]]
![[Pasted image 20240110123429.png]]

## 计算
![[Pasted image 20240110123329.png]]
# 第八章
![[Pasted image 20240109141857.png]]
![[Pasted image 20240109141906.png]]
![[Pasted image 20240109221418.png]]
其他组合情况的图解：
![[Pasted image 20240111111401.png]]
![[Pasted image 20240111111413.png]]
![[Pasted image 20240111111423.png]]
![[Pasted image 20240109141920.png]]
一个寄存器，里面一位，两个分支，两个预测表，一个表两位，初始值均为nt。寄存器初始nt
预测错误则修改寄存器和预测表的值，每次分支预测表的值（改动后的）均写入寄存器
![[fe07140e7abaf077f6e7a88a70aefc48.png]]
![[Pasted image 20240109141935.png]]
新cpi=原始cpi再加上分支预测失败或者不命中的额外开销
a) 1 + 0.2\*((0.9* 0.1* 5)+(0.1 * 3)) = 1.15
b) 1 + 0.2* 2=1.4 1.4/1.15=1.22，慢 22%。
![[Pasted image 20240109142006.png]]
[软流水的方法--国科大体系结构 期末必考题-CSDN博客](https://blog.csdn.net/csdn_muxin/article/details/114491152)
前半部分
# 第九章
![[Pasted image 20240108185648.png]]
1. 串行，进位在加法器之间传递，需要消耗大量时间
	每一级进位传递的延迟为 2T，因此生成 c16 需要 32T；
	每一级产生结果的延迟为 3T，因此生成 s15 需要（30T+3T）=33T
![[Pasted image 20240109150350.png]]
![[Pasted image 20240109150359.png]]
2. 
	1. $(a,b)-(p,g),p_i=a_i\textbar b_i;g_i=a_i \& b_i$ ,2T
	2. $(p,g)-(P,G)$,2T
	3. $(P,G)-c_{b}$ 2T
	4. $(c_{b},p,g)-c_{in}$,2T
	5. FULL ADD 3T
`11T`
![[Pasted image 20240109150736.png]]
![[Pasted image 20240109150753.png]]

![[Pasted image 20240108185619.png]]
1. 使用多个加法器；
	采用先行进位加法器两两相加，需要 2* 11T=22T 延迟
	两级加法器，第一级两个并行，第二级一个；一个加法器模块只有四位的输入
2. 使用加法树及加法器。
	使用加法树把四个数相加变成两个数相加，需要 2 级全加器延迟（6T），然后再使用先行进位加法器（11T）得到最后结果，因此共 6T+11T=17T 延迟。
	死记硬背
![[Pasted image 20240108185629.png]]
```verilog
module add16(a, b, cin, out, cout);//大模块
	input [15:0] a;//15根输
	input [15:0] b;
	input cin;
	output [15:0] out;
	output cout;
	wire [15:0] p = a|b;//声明一些导线，将input和output的东西做连接
	wire [15:0] g = a&b;
	wire [3:0] P, G;
	wire [15:0] c;
	
	assign c[0] = cin;
	C4 C0_3
(.p(p[3:0]),.g(g[3:0]),.cin(c[0]),.P(P[0]),.G(G[0]),.cout(c[3:1]));
	C4 C4_7
(.p(p[7:4]),.g(g[7:4]),.cin(c[4]),.P(P[1]),.G(G[1]),.cout(c[7:5]));
	C4 C8_11
C8_11(.p(p[11:8]),.g(g[11:8]),.cin(c[8]),.P(P[2]),.G(G[2]),.cout(c[11:9]
));
	C4 C12_15
C12_15(.p(p[15:12]),.g(g[15:12]),.cin(c[12]),.P(P[3]),.G(G[3]),.cout(c[15:13]));
C4 C_INTER(.p(P),.G(G),.cin(c[0]),.P(),.G(),.cout({c[12],c[8],c[4]}));

	assign cout = (a[15]&b[15]) | (a[15]&c[15]) | (b[15]&c[15]);
	assign out = (~a&~b&c)|(~a&b&~c)|(a&~b&~c)|(a&b&c);
endmodule

module C4(p,g,cin,P,G,cout);
	input [3:0] p, g;
	input cin;
	output P,G;
	output [2:0] cout;
	assign P=&p;
	assign G=g[3]|(p[3]&g[2])|(p[3]&p[2]&g[1])|(p[3]&p[2]&p[1]&g[0]);
	
	assign cout[0]=g[0]|(p[0]&cin);
	assign cout[1]=g[1]|(p[1]&g[0])|(p[1]&p[0]&cin);
    assign cout[2]=g[2]|(p[2]&g[1])|(p[2]&p[1]&g[0])|(p[2]&p[1]&p[0]&cin);
endmodule
```
# 第十章
![[Pasted image 20240108185441.png]]
## 第一题
页大小为 4KB=212B，页内地址为[11:0]位。cache 容量 64KB=216B，地址范围为[15:0]；cache 块大小为 32B=25B，地址范围为[4:0]
1）直接相联：cache 索引位数为地址的[15:5]，需要页着色的是地址[15:12]，共 4 位；
2）二路组相联：cache 索引位数为地址的[14:5]，需要页着色的是地址[14:12]，共 3 位；
3）四路组相联：cache 索引位数为地址的[13:5]，需要页着色的是地址[13:12]，共 2 位。
## 第二题
MissPenaltyL1=HitTimeL2 + MissPenaltyL2 ×MissRateL2
1. 直接相联：
	MissPenaltyL1=4 + 60 ×25% = 19 个时钟周期
2. 2 路组相联：
	MissPenaltyL1=5 + 60 ×20% = 17 个时钟周期
3. 4 路组相联：
	MissPenaltyL1=6 + 60 ×15% = 15 个时钟周期
## 第三题
- AMAT=实际执行时间/访问存储器次数(不是指令数量)
- 数据访问在指令中对应load和store
- MissRate = CacheMissOps/MemOps
1. 每 1000 条指令中 load/store 指令的条数是 1000×(26%/74%)=351
	1. 32KB指令 cache MissRate 为 0.0015；
	2. 32KB数据 cache MissRate 为 38/351=0.1083
	3. 指令cache和数据cache各32KB的MissRate = (1.5 + 38)/(1000+351) = 0.029264KB 
	4. 一体cache的MissRate = 40/(1000+351) = 0.0296
	5. 指令cache和数据cache各32KB组织方式缺失率更低
2. 指令 cache 和数据 cache 各 32KB 的 
	AMAT =(1000+1.5×100+38×100)/(1000+351)=3.66
	64KB一体cache的AMAT = (1000+351+40×100)/(1000+351)=3.96

# 第十一章
![[Pasted image 20240108185338.png]]
MIPS中TLB例外有3种类型：TLB重填（refill）例外指的是TLB中没有相应项；TLB失效（invalid）例外指的是相应的物理页不在内存中；TLB修改（modified）例外指的是非法写只读页。

假定操作系统页大小为4KB，同时系统的物理内存足够大，即页表分配的物理内存在程序执行过程中不会被交换到swap区上。并且在后续的分析中忽略代码和局部变量i所在的页的影响。a、b两数组大小均为65536×8=512KB。再假设a、b两数组的起始地址恰为一页的起始地址。那么a、b两数组各自均需要512KB/4KB=128个页表项。所以a、b的访问造成的`TLB invalid 例外次数为128+128=256次`；假设TLB表项为128项，每项映射连续的偶数奇数两个页，采用LRU算法。那么第一次次循环中，a、b两数组每访问相邻偶数奇数两页的首地址时，均会触发一次TLB refill例外。后续各次循环TLB中均命中。那么共触发的`TLB refill例外次数为128/2 + 128/2 = 128次。`
![[Pasted image 20240108185346.png]]
> 就是问虚拟地址会比物理地址多几位，因为物理或者虚拟地址去索引cache，tag后面的位数是不变的，tag位随地址长度而不同
1. 由于虚拟地址有 64 位，进程标识为 8 位；而物理地址是 64GB，即需要 36 位物理地址。这样，使用虚拟地址比使用物理地址总共增加的位数为 `8＋（64－36）＝8＋28＝36 位`。
2. 改变块的大小，亦或改变 cache 的其它参数，cache 占据的地址的低位的长度对于虚地址索引和物理地址索引都是一样的，所以对于 cache 的 tag 而言，两中索引方式相差位数保持不变。

![[Pasted image 20240108185354.png]]
 
# 第十二章
![[Pasted image 20240108185230.png]]
![[Pasted image 20240108200853.png]]
[cache之多核一致性(二) - MSI协议 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/95435168)

![[Pasted image 20240108185241.png]]
1. P1 对 A 的写被网络阻塞，一直没有传播到 P2 和 P3。
2. 无须施加限制。
P1            P2               P3
           barrier1         barrier1
           barrier2
A=2000   while (B!=1) {;}   while (C!=1) {;}
B=1          C=1;            D=A
barrier1   barrier2
barrier2

![[Pasted image 20240108185252.png]]
- 执行顺序以结果为导向
1. 顺序一致性：
	1. a=1 先于 print a 执行，b=1 先于 print b 执行。最终结果：a=1, b=1
	2. a=1 先于 print a 执行，print b 先于 b=1 执行。最终结果：a=1, b=0
	3. print a 先于 a=1 执行，b=1 先于 print b 执行。最终结果：a=0, b=1
2. 弱一致性：
	除顺序一致性中的三种执行序外，还可以有第 iv 中执行序：
	print a 先于 a=1 执行，print b 先于 b=1 执行。最终结果：a=0, b=0
